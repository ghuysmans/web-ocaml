<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<!-- FIXME up/down too! -->
		<div class="reveal">
			<div class="slides">
<section>
	<h1>Développement Web en OCaml</h1>
	<p>Guillaume Huysmans, 2017</p>
	<p>UMONS, Département d'informatique</p>
</section>

<section>
	<h1>Langages Web</h1>
	<ul>
		<li>
			Scripting
			<ul>
				<li class="fragment">PHP : très utilisé</li>
				<li class="fragment">
					Serveurs
					<ul>
						<li class="fragment">Node.js : asynchrone</li>
						<li class="fragment">Ruby : tooling important</li>
						<li class="fragment"><i>etc.</i></li>
					</ul>
				</li>
			</ul>
		</li>
		<li>
			Langages compilés
			<!-- FIXME source ? -->
			<span class="fragment">(moins populaires)</span>
			<ul>
				<li class="fragment">Java : parfois considéré lourd</li>
				<li class="fragment">VB, C#... (.NET)</li>
			</ul>
		</li>
	</ul>
</section>

<section>
	<h1>Scripting</h1>
	<ul>
		<li class="fragment">
			<s>Vitesse</s>
			<span class="fragment">
				(délai réseau &gt;&gt; temps de génération)
			</span>
		</li>
		<li class="fragment">
			Typage dynamique
			<ul>
				<li class="fragment">
					&laquo;&nbsp;Moins à écrire qu'en Java,
					même résultat&nbsp;&raquo;
				</li>
				<li class="fragment">
					Pas d'exécution (pas de test), pas d'erreur...
				</li>
				<li class="fragment">
					Initiatives comme TypeScript, Dart, Haxe...
					<ul>
						<li class="fragment">À nouveau trop à écrire !</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
</section>

<section>
	<h1>Objectifs</h1>
	<p>Prouver automatiquement certaines propriétés !</p>
	<ul>
		<li class="fragment">Cohérence formulaires/données</li>
		<li class="fragment">
			Gestion d'erreurs
			<ul>
				<li class="fragment">
					sans <code>null</code> potentiellement inattendu
				</li>
				<li class="fragment">
					exhaustive
					<i class="fragment">(checked exceptions ?)</i>
				</li>
				<li class="fragment">
					non intrusive
					<span class="fragment">: isolation lib/Web</span>
				</li>
			</ul>
		</li>
		<li class="fragment">
			Pages valides W3C
			<span class="fragment">(rendu plus cohérent)</span>
		</li>
		<li class="fragment">
			Liens internes corrects
			<ul>
				<li class="fragment">ni morts, ni invalides (paramètres...)</li>
			</ul>
		</li>
	</ul>
</section>

<section>
	<h1>OCaml</h1>
	<h2>Typage</h2>
	<ul>
		<li class="fragment">
			<i>statique</i> : fait à la compilation,
			rien à l'exécution
		</li>
		<li class="fragment">
			<i>fort</i> : pas de conversions implicites,
			2 + 4.0 = erreur
		</li>
		<li class="fragment">
			<i>inféré</i>
			<ul>
				<li class="fragment">
					Il n'est pas nécessaire d'écrire tous les types.
				</li>
				<li class="fragment">Fonctionne avec le polymorphisme !</li>
			</ul>
		</li>
		<!--
		<li class="fragment">vachement puissant</li>
		-->
	</ul>
	<p class="fragment">
		Le compilateur construit une preuve logique,
		cf. correspondance de Curry-Howard.
	</p>
</section>

<section>
	<h1>Types monomorphes</h1>
	<ul>
		<li class="fragment"><code>int</code></li>
		<li class="fragment"><code>string</code></li>
		<li class="fragment"><code>float -&gt; int </code></li>
	</ul>
	<p class="fragment">Le <i>currying</i> permet l'application partielle :</p>
	<ul>
		<li class="fragment">
			<code>date * date -&gt; int </code> (sans currying)
		</li>
		<li class="fragment">
			<code>date -&gt; (date -&gt; int)</code>
			<span class="fragment">
				<code>=<br>date -&gt; date -&gt; int </code>
				(associativité à droite)
			</span>
		</li>
	</ul>
</section>
<section>
	<h1>Types paramétriques</h1>
	<p>Un paramètre parfois caché permet le polymorphisme.</p>
	<ul>
		<li class="fragment">
			<code>α -&gt; α </code>
			<span class="fragment">(l'identité associe à toute valeur
				de type α la même valeur, le &laquo;&nbsp;pour tout&nbsp;&raquo;
				est implicite)</span>
		</li>
		<li class="fragment">
			<code>α list </code>
			<span class="fragment">(liste chaînée d'α)</span>
		</li>
		<li class="fragment">
			<code>α option </code>
			<span class="fragment">
				(soit <code>None</code>, soit <code>Some</code> α)
			</span>
		</li>
		<li class="fragment">
			<code>[&lt; `OK of string | `Not_found] list</code>
			<span class="fragment"><br>
				(des <code>`OK _ </code>,
				des <code>`Not_found</code>,
				ou un mélange)
			</span>
		</li>
	</ul>
</section>

<section>
	<h1>First-class values</h1>
	<ul>
		<li class="fragment">
			<code>42 </code>
			<span class="fragment">(<code>int</code>)</span>
		</li>
		<li class="fragment">
			<code>[] </code>
			<span class="fragment">(constructeur d'α <code>list</code>)</span>
		</li>
		<li class="fragment">
			<code>fun x -> x+1 </code>
			<span class="fragment">(<code>int -&gt; int</code>)</span>
		</li>

		<p class="fragment">
			Les variants polymorphes peuvent typer du HTML
			<span class="fragment">,
				voici ce que produit <code>Tyxml</code> :<br>
				<code>
				`Ul [<br>
					&nbsp;&nbsp;`Li [`PCDATA "math"];<br>
					&nbsp;&nbsp;`Li [`PCDATA "info"]<br>
				]
				</code>
			</span>
		</p>
	</ul>
</section>

<section>
	<h1>Module</h1>
	<p>Un module regroupe :</p>
	<ul>
		<li class="fragment">des types</li>
		<li class="fragment">des fonctions</li>
		<li class="fragment">des sous-modules</li>
		<li class="fragment">
			des foncteurs
			(&laquo;&nbsp;fonctions pour modules&nbsp;&raquo;)
		</li>
	</ul>
	<p class="fragment">
		Une interface (ensemble de signatures) permet de
		restreindre les types <i>(encapsulation)</i>.
	</p>
</section>

<section>
	<h1>Exemple : id</h1>
	<p>Rendre explicite toute conversion <code>int</code> ↔ id.</p>
	<table>
		<tr><td>id.mli</td><td><code>
			type t<br>
			val make: int -&gt; t<br>
			val to_int: t -&gt; int<br>
		</td></tr></code>
		<tr><td>id.ml</td><td><code>
			type t = int<br>
			let make n = n<br>
			let to_int n = n<br>
		</td></tr></code>
	</table>
	<p>
		En dehors d'<code>id.ml</code>,
		<code>t</code> est <i>opaque</i> donc <code>t≠int</code>.
	</p>
</section>

<section>
	<h1>Concurrence</h1>
	<p class="fragment">Un processus/thread est plus léger que plusieurs.</p>
	<p class="fragment">Dans Node.js, tout est asynchrone : <i>callbacks</i></p>
	<h2 class="fragment">Problèmes</h2>
	<ul>
		<li class="fragment">
			<code>try</code>/<code>catch</code> ne fonctionne plus
			<ul>
				<li class="fragment">
					Emballage des erreurs (<code>`Error</code>)
				</li>
			</ul>
		</li>
		<li class="fragment">
			Imbrication trop importante (cascade qui devient vite illisible,
			on parle parfois de <i>callback hell</i>)
		</li>
	</ul>
</section>

<!-- FIXME <, > in Mathjax? -->
<section>
	<h1>Monade</h1>
	<ul>
		<li class="fragment">
			<code>return</code> : \(\alpha \mapsto \alpha m\)
		</li>
		<li class="fragment">
			<code>>>= </code> (<code>bind</code>) :
				\(\alpha m \mapsto \left(\alpha \mapsto \beta m\right)
				\mapsto \beta m\)
		</li>
		<li class="fragment">
			<i>Identité</i> :
			$$\forall x, \forall f, \texttt{(return x >>= f) = f x}$$
			$$\forall m, \texttt{(m >>= (fun x -> return x)) = m}$$
		</li>
		<li class="fragment">
			<i>Associativité</i> : \(\forall m, \forall n, \forall o\)
			(\(o\) sans variable libre \(a\))
			$$\texttt{m >>= (fun a -> (n >>= fun b -> o))} =$$
			$$\texttt{(m >>= fun a -> n) >>= fun b -> o}$$
		</li>
	</ul>
</section>

<section>
	<h1>Promesses</h1>
	<p class="fragment">
		Pipeline, séquence de transformations avec <code>bind</code>.
	</p>
	<p class="fragment">
		En OCaml, les fonctions restent imbriquées mais la syntaxe n'impose pas
		l'utilisation de parenthèses. Les variables sont partagées
		grâce à des <i>closures</i>.
	</p>
	<p class="fragment">
		Le type d'une fonction exprime qu'elle est asynchrone, sa valeur de
		retour est &laquo;&nbsp;emballée&nbsp;&raquo; :
		<code>int -&gt; int t</code>
	</p>
</section>

<section>
	<h1>Exemple</h1>
	<p><code>Lwt</code> implémente ces promesses.</p>
	<!-- FIXME don't center! -->
	<code>
		open Lwt.Infix<br>
		(* ... *)<br>
		read_book title<br>
		&gt;&gt;= translate ~dest:"fr"<br>
		&gt;&gt;= Views.translation<br>
		&gt;&gt;= respond ~status:`OK
	</code>
</section>

<section>
	<h1>Erreurs</h1>
	<p>
		En introduisant des variants polymorphes,
		on peut garantir que toutes les erreurs seront gérées.
	</p>
	<h2>Exemple amélioré</h2>
	<code>
		open Error<br>
		(* ... *)<br>
		read_book title<br>
		&gt;&gt;= translate ~dest:"fr"<br>
		&gt;&gt;= Views.translation
	</code>
</section>

<section>
	<h1>Formulaires</h1>
	<!-- FIXME définition... -->
	<div class="fragment">
		<p>
			Un GADT permet de garder le type à l'exécution et
			d'en sortir la valeur grâce à une fonction polymorphe :
		</p>
		<code>
			type α typ =<br>
			&nbsp;&nbsp;| Int: int -&gt; int typ<br>
			&nbsp;&nbsp;| Str: string -&gt; string typ
		</code>
	</div>
	<div class="fragment">
		<p>La valeur et son type sont gardés en cas d'erreur :</p>
		<code>
			type (α, β) t =<br>
			&nbsp;&nbsp;| Valid of α<br>
			&nbsp;&nbsp;| Invalid of α * β
		</code>
	</div>
</section>

<section>
	<h1>Formulaires (2)</h1>
	<ul>
		<li class="fragment">
			<code>read </code> lit une<code>&nbsp;string option</code>
		</li>
		<li class="fragment">
			<code>required </code> rend une valeur obligatoire
		</li>
		<li class="fragment">
			<code>to_int</code> convertit en entier,
			<code>min</code> teste une borne :<br>
			<code>read uri "age" |&gt; to_int |&gt; min 5</code>
		</li>
		<li class="fragment">
			<code>input</code> génère le champ HTML correspondant
		</li>
		<li class="fragment">
			<code>get</code> donne la valeur OCaml correspondant :<br>
			<code>let bio = read uri "bio" |&gt; get in</code>
		</li>
	</ul>
</section>

<section>
	<h1>Conclusion</h1>
	<ul>
		<li class="fragment">
			Les objectifs de fiabilité décrits au début sont atteignables grâce
			au typage d'OCaml, ses variants polymorphes sont assez uniques
			en leur genre.
		</li>
		<li class="fragment">
			&laquo;&nbsp;Typé&nbsp;&raquo; n'est pas synonyme de
			&laquo;&nbsp;pénible&nbsp;&raquo; : les types peuvent être inférés,
			il ne devrait pas être nécessaire de toujours tous les écrire.
		</li>
	</ul>
</section>

<section>
	<h1>Aller plus loin</h1>
	<ul>
		<li>
			<code>do</code> à la Haskell pour que le code soit aussi facile à
			écrire que de l'impératif, sans l'être. Les <i>modular
			implicits</i> semblent être nécessaires.
		</li>
		<li>
			Liens typés : créer une valeur dont le type contient les paramètres
			du liens et l'utiliser à la fois pour le routage et la génération
			du code HTML.
		</li>
	</ul>
</section>

<section>
	<h1>Eliom</h1>
	<!-- typo? -->
	<!-- TODO logo? -->
	<p>
		BeSport maintient Eliom, un framework assez abouti qui répond à nos
		objectifs (entre autres). En outre, il compile le code OCaml en
		JavaScript afin d'exécuter côté client du code type-safe et de ne plus
		avoir qu'un seul langage à connaître (et maîtriser ?).
	</p>
	<p>J'y fais mon stage !</p>
</section>

<section>
	<h1>Des questions ?</h1>
	<p>
		Cette présentation est sur GitHub :<br>
		<!-- FIXME? -->
		<a href="https://ghuysmans.github.io/web-ocaml/index.html">
		https://ghuysmans.github.io/web-ocaml/index.html
		</a>
	</p>
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			//TOOD multiplex!
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/math/math.js', async: true }
				]
			});
		</script>
	</body>
</html>
