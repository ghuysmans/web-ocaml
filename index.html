<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<style>
		tr.pics {
			background-color: white;
		}
		tr.pics img {
			box-shadow: none;
		}
		</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<!-- FIXME up/down too! -->
		<div class="reveal">
			<div class="slides">

<section>
	<h1>Développement Web en OCaml</h1>
	<p>Guillaume Huysmans, 2017</p>
	<p>UMONS, Département d'informatique</p>
</section>

<section>
	<h1>Scripting</h1>
	<ul>
		<li class="fragment">
			<s>Vitesse</s>
			<span class="fragment">
				(délai réseau &gt;&gt; temps de génération)
			</span>
		</li>
		<li class="fragment">
			Typage dynamique
			<ul>
				<li class="fragment">
					&laquo;&nbsp;Moins à écrire qu'en Java,
					même résultat&nbsp;&raquo;
				</li>
				<li class="fragment">
					Pas d'exécution (pas de test), pas d'erreur...
				</li>
				<li class="fragment">
					Retour vers du typage statique avec TypeScript
					<ul>
						<li class="fragment">
							À nouveau trop à écrire (bibliothèques...) !
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
</section>

<section>
	<h1>À éviter</h1>
	<ul>
		<li class="fragment">
			Débogage complexe, erreurs &laquo;&nbsp;prévisibles&nbsp;&raquo; :
			<pre><code>TypeError: null has no properties</code></pre>
		</li>
		<li class="fragment">
			Constante qui change, formule incorrecte
		</li>
	</ul>
</section>

<section>
	<h1>Objectifs</h1>
	<p>Prouver automatiquement certaines propriétés !</p>
	<ul>
		<li class="fragment">Cohérence formulaires/données</li>
		<li class="fragment">
			Gestion d'erreurs
			<ul>
				<li class="fragment">
					sans <code>null</code> potentiellement inattendu
				</li>
				<li class="fragment">
					exhaustive
					<i class="fragment">(checked exceptions ?)</i>
				</li>
				<li class="fragment">
					<!-- une raison. L'autre : inféré donc pas gênant -->
					non intrusive
					<span class="fragment">: isolation lib/Web</span>
				</li>
			</ul>
		</li>
		<li class="fragment">
			Pages valides W3C :
			<ul>
				<li class="fragment">Rendu plus cohérent</li>
				<li class="fragment">Accessibilité</li>
			</ul>
		</li>
	</ul>
</section>

<section>
	<h1>OCaml</h1>
	<h2>Typage</h2>
	<ul>
		<li class="fragment">
			<i>statique</i> : fait à la compilation,
			rien à l'exécution
		</li>
		<li class="fragment">
			<i>fort</i> : pas de conversions implicites,
			2 + 4.0 = erreur
		</li>
		<li class="fragment">
			<i>inféré</i>
			<ul>
				<li class="fragment">
					Il n'est pas nécessaire d'écrire tous les types.
				</li>
				<li class="fragment">Polymorphisme paramétrique !</li>
			</ul>
		</li>
		<!--
		<li class="fragment">vachement puissant</li>
		-->
	</ul>
</section>

<section>
	<h1>Types monomorphes</h1>
	<ul>
		<li class="fragment"><code>int</code></li>
		<li class="fragment"><code>string</code></li>
		<li class="fragment"><code>float -&gt; int </code></li>
	</ul>
</section>
<section>
	<h1>Types paramétriques</h1>
	<ul>
		<li class="fragment">
			<code>α list </code> (liste chaînée d'α),
			par ex. <code>[1; 2; 3]</code>
		</li>
		<li class="fragment">
			<code>α option</code>
			<ul>
				<li class="fragment">
					Soit <i>rien</i> : <code>None </code>
					(de type <code> α option</code>)
				</li>
				<li class="fragment">
					Soit une valeur : <code>Some 2 </code>
					(de type <code> int option</code>)
				</li>
			</ul>
		</li>
		<li class="fragment">
			<code>[&lt; `OK | `Not_found] </code> : variant polymorphe
			<ul>
				<li class="fragment">
					Sous-type de <code>[`OK | `Not_found]</code>
				</li>
				<li class="fragment">
					<code>`OK</code>, <code>`Not_found </code> ou un des deux
				</li>
			</ul>
		</li>
	</ul>
</section>

<section>
	<h1>Tyxml</h1>
	<pre><code data-trim>
(* tyxml.mli simplifié *)
type 'a elt
val table :
  (* ... *)
  ?columns: [< `Colgroup] elt list ->
  [< `Tr] elt list ->
  [> `Table] elt
(* utilisation *)
type t = {name: string; age: int}
let to_row x = tr [
  td [pcdata x.name];
  td [pcdata (string_of_int x.age)]
]
let to_table l = table (List.map to_row l)
	</code></pre>
</section>

<section>
	<h1>Exemple d'erreur</h1>
	<pre><code data-trim>
let view l = [p ["Members:"; br (); to_table l]]
	</code></pre>
	<pre>
Error: This expression has type
  ([> Html_types.table ] as 'a) Tyxml.Html.elt = 'a Tyxml_html.elt
but an expression was expected of type
  ([< Html_types.p_content_fun ] as 'b) Tyxml.Html.elt =
    'b Tyxml_html.elt
Type 'a = [> `Table ] is not compatible with type
  'b =
    [< `A of Html_types.phrasing_without_interactive
     | `Abbr
     ... ]
The second variant type does not allow tag(s) `Table
	</pre>
</section>
<!-- FIXME autre slide avec erreur dont les mots-clés sont colorés -->
<!-- TODO template par fonctions composées -->

<section>
	<h1>Module</h1>
	<p>Un module regroupe :</p>
	<ul>
		<li class="fragment"><i>des types</i></li>
		<li class="fragment">des fonctions</li>
		<li class="fragment">des sous-modules</li>
		<li class="fragment">
			des foncteurs
			(&laquo;&nbsp;fonctions pour modules&nbsp;&raquo;)
		</li>
	</ul>
	<p class="fragment">
		Une interface (ensemble de signatures) permet de
		restreindre les types (par <i>abstraction</i>).
	</p>
</section>

<section>
	<h1>Exemple : id</h1>
	<p>Rendre explicite toute conversion <code>int</code> ↔ id.</p>
	<pre><code>
(* id.mli *)
type t (* abstrait, opaque *)
val make: int -> t
val to_int: t -> int

(* id.ml *)
type t = int
let make n = n
let to_int n = n
	</code></pre>
	<p>
		En dehors d'<code>id.ml</code>,
		<code>t</code> est <i>opaque</i>, donc <code>t≠int</code>.
	</p>
</section>

<section>
	<h1>Concurrence</h1>
	<p class="fragment">Un processus/thread est plus léger que plusieurs.</p>
	<p class="fragment">En Node.js, asynchrone \(\implies\) <i>callback</i>.</p>
	<p class="fragment">
		Dans un serveur avec plusieurs clients,
		un gestionnaire de requêtes qui attend
		ne doit pas bloquer les autres.
	</p>
	<h2 class="fragment">Problèmes</h2>
	<ul>
		<li class="fragment">
			<code>try</code>/<code>catch</code> ne fonctionne plus
		</li>
		<li class="fragment">Imbrication trop importante (syntaxe)</li>
	</ul>
</section>

<section>
	<h1>Monade</h1>
	<ul>
		<li class="fragment">
			<code>return</code> : \(\alpha \rightarrow \alpha m\)
		</li>
		<li class="fragment">
			<code>>>= </code> (<code>bind</code>) :
				\(\alpha m \rightarrow \left(\alpha \rightarrow \beta m\right)
				\rightarrow \beta m\)
		</li>
	</ul>
	<table class="fragment">
		<tr>
			<td><code>return</code></td>
			<td></td>
			<td><code>bind</code></td>
		</tr>
		<tr class="pics">
			<td><img src="return.png"></td>
			<td><img src="ouch.png"></td>
			<td><img src="bind.png"></td>
		</tr>
		<tr>
			<td align="right" colspan="3">
				<small>
					<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">source</a> : Aditya Bhargava
				</small>
			</td>
		</tr>
	</table>
	<p>
	</p>
		<!--
		<li class="fragment">
			<i>Identité</i> :
			$$\forall x, \forall f, \texttt{(return x >>= f) = f x}$$
			$$\forall m, \texttt{(m >>= (fun x -> return x)) = m}$$
		</li>
		<li class="fragment">
			<i>Associativité</i> : \(\forall m, \forall n, \forall o\)
			(\(o\) sans variable libre \(a\))
			$$\texttt{m >>= (fun a -> (n >>= fun b -> o))} =$$
			$$\texttt{(m >>= fun a -> n) >>= fun b -> o}$$
		</li>
		-->
	</ul>
</section>

<section>
	<h1>Promesse</h1>
	<p class="fragment">
		Valeur accessible plus tard, transformée avec <code>bind</code>.
		Elle est &laquo;&nbsp;emballée&nbsp;&raquo; :
		<code>int -&gt; int t</code>
	</p>
	<p class="fragment">
		Le calcul progresse au fil de ces transformations.
	</p>
</section>

<section>
	<h1>Exemple</h1>
	<pre><code class="ocaml" data-trim>
(* sans Lwt *)
let f title =
  let s = read_book title in
  let fr = translate ~dest:"fr" s in
  let v = Views.book title fr in
  resp_ok v

(* avec Lwt *)
let f title =
  read_book title
  >>= translate ~dest:"fr"
  >>= Views.book title
  >>= resp_ok
	</code></pre>
</section>

<section>
	<h1>Erreurs</h1>
	<p>
		Avec des variants polymorphes,
		les erreurs possibles seront accumulées dans le type.
	</p>
	<p class="fragment">
		Le combinateur <code>&gt;&gt;&gt;</code> transmet les erreurs
		<!-- quand il n'y a pas de valeur à transformer -->
		et <code>&gt;&gt;!</code> transforme ces erreurs (en pages, ici).
	</p>
	<div class="fragment">
		<h2>Exemple amélioré</h2>
		<pre><code class="ocaml" data-trim>
let f title =
  read_book title          (* (string, [< `NF]) t *)
  >>> translate ~dest:"fr" (* (string, [< `NF, `CT] t *)
  >>> Views.translation    (* (doc, [< `NF, `CT] t *)
  >>! handle_errors        (* (doc, [< `Redir of string] t *)
		</code></pre>
	</div>
</section>

<section>
	<h1>Formulaires</h1>
	<p>
		Le type des champs affichés doit correspondre à
		celui des valeurs attendues par le programme.
	</p>
	<pre class="fragment"><code class="ocaml" data-trim>
type t = {name: string; age: int option}
let form ?(t = {name = ""; age = None}) () =
  form `Post [
    h2 [pcdata "Form"];
    label "Name: " (make_string "name" t.name |> input);
    label "Age: " (make_int_o "age" t.age |> input);
    button [pcdata "Submit"];
  ]
let read data =
  read data "name" |> required |> get >>> fun name ->
  read data "age" |> to_int |> get >>> fun age ->
  return {name; age} (* (t, [< `NaN | `Required]) Error.t *)
	</code></pre>
	<!-- TODO screenshot pour montrer l'interaction -->
</section>

<section>
	<h1>Conclusion</h1>
	<ul>
		<li class="fragment">
			Les objectifs de fiabilité décrits au début sont atteignables grâce
			au typage d'OCaml; les variants polymorphes et les GADT sont très
			utiles même si on ne les retrouve pas dans beaucoup de langages.
		</li>
		<li class="fragment">
			&laquo;&nbsp;Statiquement typé&nbsp;&raquo; n'est pas synonyme de
			&laquo;&nbsp;verbeux&nbsp;&raquo; : les types peuvent être inférés.
		</li>
	</ul>
</section>

<section>
	<h1>Aller plus loin</h1>
	<ul>
		<li class="fragment">
			Lien typé :
			<ul>
				<li>Valeur : URI</li>
				<li>Paramètre de type : type des paramètres</li>
				<li>Utilisé pour le routage et le rendu</li>
			</ul>
		</li>
		<li class="fragment">
			<a href="https://github.com/ocsigen/js_of_ocaml">
			js_of_ocaml
			</a>
			compile du OCaml en JavaScript
		</li>
	</ul>
</section>

<section>
	<h1>Merci !</h1>
</section>

<section>
	<h1>Des questions ?</h1>
	<p>
		Cette présentation est sur GitHub :<br>
		<a href="https://ghuysmans.github.io/web-ocaml/">
		https://ghuysmans.github.io/web-ocaml/
		</a>
	</p>
	<p>
		Les bibliothèques décrites, aussi !<br>
		<a href="https://github.com/ghuysmans/web-ocaml">
		https://github.com/ghuysmans/web-ocaml
		</a>
	</p>
	<p>
		Le site officiel d'OCaml propose un bon tutoriel :<br>
		<a href="http://ocaml.org/">
		http://ocaml.org/
		</a>
	</p>
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			//TOOD multiplex!
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/math/math.js', async: true }
				]
			});
		</script>
	</body>
</html>
